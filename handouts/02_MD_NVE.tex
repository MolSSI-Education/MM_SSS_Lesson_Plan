%\documentclass[12pt]{article}
\documentclass[aip,jcp,preprint,superscriptaddress,floatfix]{revtex4-1}
\usepackage{url,graphicx,tabularx,array,geometry,amsmath,listings}
\setlength{\parskip}{2ex} %--skip lines between paragraphs
\setlength{\parindent}{20pt} %--don't indent paragraphs

\setlength{\headheight}{-50pt}
\setlength{\textheight}{700pt}
\setlength{\textwidth}{500pt}
\setlength{\oddsidemargin}{-10pt}
\setlength{\footskip}{50pt}
\usepackage{graphicx}% Include figure files
\usepackage{bm}
\usepackage{hyperref}
\graphicspath{{./Figures/}}

%-- Commands for header
\renewcommand{\title}[1]{\textbf{\large{#1}}\\}
\renewcommand{\line}{\begin{tabularx}{\textwidth}{X>{\raggedleft}X}\hline\\\end{tabularx}\\[-0.5cm]}
\newcommand{\leftright}[2]{\begin{tabularx}{\textwidth}{X>{\raggedleft}X}#1%
& #2\\\end{tabularx}\\[-1cm]}

%\linespread{2} %-- Uncomment for Double Space
\begin{document}

\title{\center{Molecular Dynamics} }
\rule{\textwidth}{1pt}
\leftright{The Molecular Sciences Software Institute}{Eliseo Marin-Rimoldi} %-- left and right positions in the header

\bigskip

\section{Introduction}

Your first assignment consisted on implementing a Monte Carlo (MC) simulation
for the Lennard-Jones (LJ) particle in the canonical ensemble. 
As part of this task,
you developed code that computed pairwise energies and forces for this model.

The objective of this task is to extend your code by including the
necessary functionality to simulate the NVE ensemble of configurations 
of the LJ model using the Molecular Dynamics (MD) method. You will be 
assigned to work in teams to develop this project. The team will
decide how is best to design the new code: what is the shared functionality
between the two methods? how does the library should look like? How can
we improve reusability and extensibility? What data
structures should be used? What are the unit tests 
that might be used? The primary learning goal of this activity 
is to think about teamwork and interoperability.

In the following sections, the relevant equations of the MD 
method will be presented and reference data for validation will be provided.

\subsection{Molecular Dynamics method}

A very common technique to simulate equilibrium and nonequilibrium
properties is the Molecular Dynamics method. 
The objective of is to simulate the evolution of a model over time
by integrating the Newtonian equations of motion to 
extract dynamic and thermodynamic properties. Thermodynamic
averages should be identical to those obtained by MC sampling
due to the ergodic hypothesis, given that we use the same model at the
same conditions. One advantage of MD over MC simulations is 
the ability to compute dynamical properties such as diffusivities or 
viscosities. 

The Newtonian equations of motions in Cartesian coordinates are

\begin{equation}
	\ddot{\mathbf{r}} = \frac{\mathbf{f}_i\left( \mathbf{r^N} \right) }{\textit{m}_i}
\end{equation}

Where $\mathbf{r^N}$, $\mathbf{f}_i$ and
 $\textit{m}_i$ are the vector of atomic Cartesian coordinates, the forces 
 and the mass of each atom, respectively.
These are $3N$ second order differential equations, where $N$ is the number 
of atoms in the system. There are various finite difference approaches to solve
such equations. The basic idea in all of them is to move 
across time using finite time steps $\delta t$ and thus generate new atomic
positions. A good integration scheme is one that conserves energy 
and momentum, minimizes force evaluations and is stable and accurate. 

\section{Velocity Verlet Algorithm}

One particularly good and widely used method is the Velocity Verlet algorithm
which is an improvement on the original Verlet method (i.e. less memory
intensive). The equations of this method are

\begin{equation}
	r \left( t + \delta t \right) = r \left( t \right) + v \left( t \right) \delta t + \frac{f \left(t \right) }{2 m} \delta t ^2
\label{eq:verlet.position.update}
\end{equation}

\begin{equation}
	v \left( t + \delta t \right) = v \left( t \right) + \frac{f \left( t + \delta t \right) + f \left(t \right) }{2m} \delta t
\end{equation}

This algorithm can be implemented as follows

\begin{itemize}
	\item Given a system state (i.e. positions and velocities), 
		compute forces on each atom
	\item Update the positions using Equation \ref{eq:verlet.position.update}
	\item Do a partial update to the velocities using the current forces
		\begin{equation}
			v \leftarrow v + \frac{f}{2m} \delta t
		\end{equation}
	\item Compute new forces using the updated positions
	\item Complete the update of the velocities with the old forces
		\begin{equation}
			v \leftarrow v + \frac{f}{2m} \delta t
		\end{equation}

\end{itemize}

\subsection{Technical considerations}

\textbf{Energy conservation and time step. } The velocity verlet algorithm has very good
energy conservation properties. It is always a good check to see if 
there is no drift in energy during the course of the simulation. If the algorithm 
is correctly implemented, the energy drift can be mitigated by reducing the 
time step. 

\textbf{Initialization. } For the problem at hand, atoms can be
placed in a lattice as an initial configuration.
An alternative approach is to place atoms randomly, but this can be
dangerous as core overlaps might exist, leading to huge repulsion forces. 
In this case, an initial relaxation stage could be performed using
translational MC moves.

Velocities must also be initialized. This can be done by randomly selecting
velocities
from a Maxwell-Boltzmann distribution at the desired temperature T

\begin{equation}
	\rho \left(v_{ix}\right) = \left( \frac{m_i}{2 \pi k_B T} \right) ^ {1/2} exp \left( - \frac{m_i v_{ix}^2 } {2 k_B T }  \right)
\end{equation}
%
This provides the probability that 
an atom $i$ has a velocity $v_{ix}$ $x$ direction.

Note that the Maxwell-Boltzmann distribution
is a Gaussian distribution with zero mean and variance

\begin{equation}
	\sigma_v^2 = \frac{k_B T}{m_i}
\end{equation}

Alternatively, the initial velocities can also be chosen from a uniform distribution.
The Maxwell-Boltzmann distribution will be achieved rapidly.

Once the velocities are assigned to the atoms, we must set the system momentum
to zero to avoid any translational drift. We do this by 

\begin{itemize}
	\item Find the net momentum of the system $\mathbf{P} = \sum m_i \mathbf{v}_i$
	\item Reassign initial atomic velocities as
		\begin{equation}
			\mathbf{v}_i \leftarrow \mathbf{v}_i - \frac{\mathbf{P}} { N m_i}
		\end{equation}
\end{itemize}

\textbf{Equilibration. } During this stage of the simulation, the system relaxes to 
equilibrium from the initial state. Monitoring various properties such as potential,
 kinetic and total energies, temperature and pressure are ways to determine if the system has
reached equilibrium. While the total energy must be constant, the potential and kinetic energies
can fluctuate. The velocities should follow a Maxwell-Boltzmann distribution and kinetic
energies should be the same in all three directions. 

In the equilibration phase, it is common practice to adjust the velocities of 
the particles to maintain a constant temperature. The easiest way to alter the
temperature of the system is to scale the velocities by a factor $\lambda$
calculated to enforce
the total kinetic energy $K$ to be equal to the average kinetic energy at a target
temperature.

\begin{equation}
	\mathbf{v}^N_{new} = \lambda \mathbf{v}^N
\end{equation}

where 

\begin{equation}
	\lambda = \left( \frac{k_B T N_{DOF}}{\sum m_i | \mathbf{v}_i^2 |} \right)
\end{equation}

where $N_{DOF}$ is the number of degrees of freedom in the system. 
Note that $N_{DOF} = N - N_c$, where $N_c$ is the number of constraints. 
For a large enough system, $N_{DOF} \approx 3N$. 

Unfortunately, this simple method alters the natural dynamics of the NVE ensemble
and consequently does not rigorously this ensemble. In particular, some dynamical
properties and some fluctuation quantities (e.g. heat capacity) cannot
be computed reliably. Thus, in a microcanonical ensemble simulation, properties
are computed only in the production stage, when velocity rescaling is no longer
applied. 

\textbf{Temperature. } The instantaneous temperature in a simulation can be computed
as 

\begin{equation}
	T = \frac{2 K}{N_{DOF} k_B}
\end{equation}

\textbf{Radial distribution function. } 

\textbf{Periodic boundary conditions, minimum image distance, 
energy truncation and tail correction. } Your MD code should also implement 
these features.

\end{document}
